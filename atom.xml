<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>117blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-13T01:25:17.890Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ChicWu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>责任链设计模式</title>
    <link href="http://yoursite.com/2018/09/12/%E8%B4%A3%E4%BB%BB%E9%93%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/12/责任链设计模式/</id>
    <published>2018-09-12T11:18:45.000Z</published>
    <updated>2018-09-13T01:25:17.890Z</updated>
    
    <content type="html"><![CDATA[<p>　　责任链设计模式属于行为类设计模式，责任链设计模式顾名思义就好比链表一样，不同的是责任链是由多个处理不同任务的对象节点组成，每个对象节点包含着责任链上下一个对象节点的引用，这样请求就可以在这条链上进行传递，直到有一个对象节点可以处理请求，或者每个对象节点都可以处理请求，并传递给下家，直到链上的每个对象节点都处理完，这样就能在不影响客户端的前提下在责任链上任意的更改处理对象节点。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>　　例如我们去政府部门去办事，有时候就会遇见官员责任踢球，这就是一个责任链，你的问题我能够解决我就解决，如果我不能解决就推卸给另一个部门，至于谁最后处理这个事情，政府部门为了将屁民的请求也官员耦合在一起，让多个（部门）都可以接受请求，将这些（部门）对象连接成一条链，并且沿着这条链传递请求，直到有（部门）对象处理它为止。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul><li>降低客户段与处理节点的耦合度</li><li>简化处理节点的相互连接</li><li>增强了给处理节点指派职责的灵活性</li><li>简化了如何增加一个处理节点</li><li><code>缺点</code>：不能保证请求一定被接收；且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便；另外如果使用不恰当容易产生循环调用。</li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/img/责任链设计模式1.jpg" alt="结构"><br>　　一个典型的对象结构可能如下图所示：<br><img src="/img/责任链设计模式2.jpg" alt="结构"><br>　　主要有以下三个对象组成：</p><ul><li>Handler(抽象处理者)：定义一个处理请求的接口，和一个后继连接(可选)</li><li>ConcreteHandler(具体处理者)：处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。</li><li>Client(客户类)：向一个链上的具体处理者ConcreteHandler对象提交请求。</li></ul><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>　　责任链按照处理对象处理的方法可以分为两种模式：<br>　　a) 纯的责任链模式：一个具体处理者角色处理只能对请求作出两种行为中的一个：一个是自己处理（承担责任）；另一个是把责任推给下家。<code>不允许出现某一个具体处理者对象在承担了一部分责任后又将责任向下传</code>的情况。请求在责任链中必须被处理，<code>不能出现无果而终的结局</code>。<br>　　b) 不纯的责任链模式：在一个纯的职责链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的职责链模式里面，一个请求可以最终不被任何接收端对象所接收。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>　　a) 不纯的责任链模式：<br>　　Servlet中的过滤器就采用了不纯的责任链模式，FIlter中的FilterChan对象保存了最终到Servlet对象的所有FIlter对象，这些对象存储在ApplicationFIlterChan对象的Fil数组中，在FilterChain链上没执行一个Filter对象，数组的当前计数就会增加1，直到计数等于数组的长度为止，当FilterChain上的所有Filte执行完毕后就会执行Servlet，所以ApplicationFilterChain中会持有Servlet对象的引用。<br>　　b) 纯的责任链设计模式：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　责任链设计模式属于行为类设计模式，责任链设计模式顾名思义就好比链表一样，不同的是责任链是由多个处理不同任务的对象节点组成，每个对象节点包含着责任链上下一个对象节点的引用，这样请求就可以在这条链上进行传递，直到有一个对象节点可以处理请求，或者每个对象节点都可以处理请求，并传递给下家，直到链上的每个对象节点都处理完，这样就能在不影响客户端的前提下在责任链上任意的更改处理对象节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>InnerClass</title>
    <link href="http://yoursite.com/2018/09/12/%E9%9C%87%E6%83%8A%EF%BC%81%E5%A4%96%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%86%85%E9%83%A8%E7%B1%BBprivate%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2018/09/12/震惊！外部类可以访问内部类private变量/</id>
    <published>2018-09-12T06:08:55.000Z</published>
    <updated>2018-09-13T06:44:13.493Z</updated>
    
    <content type="html"><![CDATA[<p>　　<code>震惊！外部类竟可以访问内部类private变量！！！</code><br><a id="more"></a><br>　　标题致敬著名的某头条，在最近的开发过程中写了一段类似与这样的代码，惊奇的发现外部类竟然能对内部类做这样的事情！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private String outerStr;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        new InnerClass().innerStr = &quot;外部类也可以修改内部类私有变量&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    public class InnerClass&#123;</span><br><span class="line">        private String innerStr;</span><br><span class="line">        public void test1()&#123;</span><br><span class="line">            outerStr = &quot;内部类可以直接修改外部类私有变量&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　以我的暴脾气，既然遇见了一个问题就要刨根问底然后我有写了如下的测试，分别测试了成员内部类和方法内部类的私有变量以及私有方法的，并且还特地的将成员内部类与方法内部类写成了一样的。发现并不会出现类冲突，但是在方法内方法内部类会覆盖掉成员内部类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private String outerStr = &quot;外部类的私有变量&quot;;</span><br><span class="line">    //成员内部类</span><br><span class="line">    private class InnerClass&#123;</span><br><span class="line">        private InnerClass()&#123;</span><br><span class="line">            System.out.println(&quot;外部类可以调用成员内部类的私有构造方法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        private String innerStr = &quot;成员内部类的私有变量&quot;;</span><br><span class="line">        private void test()&#123;</span><br><span class="line">            System.out.println(&quot;成员内部类可以直接调用&quot;+outerStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;外部类可以通过实例对象调用&quot;+new InnerClass().innerStr);</span><br><span class="line">        new InnerClass().test();</span><br><span class="line">        //方法内部类</span><br><span class="line">        class InnerClass&#123;</span><br><span class="line">            private InnerClass()&#123;</span><br><span class="line">                System.out.println(&quot;外部类可以调用方法内部类的私有构造方法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            private String innerStr = &quot;方法内部类的私有变量&quot;;</span><br><span class="line">            private void test()&#123;</span><br><span class="line">                System.out.println(&quot;方法内部类可以直接调用&quot;+outerStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //注意要有先后顺序</span><br><span class="line">        System.out.println(&quot;外部类可以通过实例对象调用&quot;+new InnerClass().innerStr);</span><br><span class="line">        new InnerClass().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　<code>运行结果：</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">外部类可以调用成员内部类的私有构造方法</span><br><span class="line">外部类可以通过实例对象调用成员内部类的私有变量</span><br><span class="line">外部类可以调用成员内部类的私有构造方法</span><br><span class="line">成员内部类可以直接调用外部类的私有变量</span><br><span class="line">外部类可以调用方法内部类的私有构造方法</span><br><span class="line">外部类可以通过实例对象调用方法内部类的私有变量</span><br><span class="line">外部类可以调用方法内部类的私有构造方法</span><br><span class="line">方法内部类可以直接调用外部类的私有变量</span><br></pre></td></tr></table></figure></p><p>　　言归正传，下面正式开始全面解析内部类。</p><h1 id="为什么使用内部类"><a href="#为什么使用内部类" class="headerlink" title="为什么使用内部类"></a>为什么使用内部类</h1><h1 id="内部类与外部类的联系"><a href="#内部类与外部类的联系" class="headerlink" title="内部类与外部类的联系"></a>内部类与外部类的联系</h1><h2 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h2><h2 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a>外部类访问内部类</h2><h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><h2 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h2><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;code&gt;震惊！外部类竟可以访问内部类private变量！！！&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Babel过滤URL</title>
    <link href="http://yoursite.com/2018/09/11/babel%E8%BF%87%E6%BB%A4URL/"/>
    <id>http://yoursite.com/2018/09/11/babel过滤URL/</id>
    <published>2018-09-11T08:30:18.000Z</published>
    <updated>2018-09-13T02:55:01.852Z</updated>
    
    <content type="html"><![CDATA[<p>　　通过nodejs+babel查找所有js文件中的URL<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">const babylon = require(&apos;babylon&apos;);</span><br><span class="line">const Traverse = require(&apos;babel-traverse&apos;).default;</span><br><span class="line">const generator = require(&apos;babel-generator&apos;).default;</span><br><span class="line">const Types = require(&apos;babel-types&apos;);</span><br><span class="line">const babel = require(&apos;babel-core&apos;);</span><br><span class="line"></span><br><span class="line">//解析需要遍历的文件夹，我这以E盘根目录为例</span><br><span class="line">var filePath = path.resolve(&apos;C:\\Users\\Administrator.FO13YM4ZWHL5OAN\\Desktop\\babel\\AstForBabel\\conference&apos;);</span><br><span class="line">var reg = /(.js)$/i;</span><br><span class="line"></span><br><span class="line">//调用文件遍历方法</span><br><span class="line">fileDisplay(filePath);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件遍历方法</span><br><span class="line"> * @param filePath 需要遍历的文件路径</span><br><span class="line"> */</span><br><span class="line">console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;程序开始&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</span><br><span class="line"></span><br><span class="line">function findurl(filedir)&#123;</span><br><span class="line">  // urlast转换 </span><br><span class="line">  try&#123;</span><br><span class="line">    var code =fs.readFileSync(filedir, &apos;utf8&apos;);</span><br><span class="line">    var ast = babylon.parse(code);</span><br><span class="line">    Traverse(ast,&#123;</span><br><span class="line">      Identifier(path)&#123;</span><br><span class="line">        if (path.node.name === &quot;url&quot;) &#123;</span><br><span class="line">          var parentcode = generator(path.parent).code;</span><br><span class="line">          var reg1 = /^(url)[:=\s]/i;</span><br><span class="line">          if (reg1.test(parentcode)) &#123;</span><br><span class="line">            console.log(parentcode);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // console.log(filedir);</span><br><span class="line">    fs.writeFile(filedir,generator(ast).code,function(err)&#123;</span><br><span class="line">        if(err) console.log(&apos;写文件操作失败&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; catch(error)&#123;</span><br><span class="line">    // console.log(&quot;!!!!!!!!!!&quot; + filedir);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fileDisplay(filePath)&#123;</span><br><span class="line">  //根据文件路径读取文件，返回文件列表</span><br><span class="line">  fs.readdir(filePath,function(err,files)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      console.warn(err)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      //遍历读取到的文件列表</span><br><span class="line">      files.forEach(function(filename)&#123;</span><br><span class="line">        //获取当前文件的绝对路径</span><br><span class="line">        var filedir = path.join(filePath,filename);</span><br><span class="line">        //根据文件路径获取文件信息，返回一个fs.Stats对象</span><br><span class="line">        fs.stat(filedir,function(eror,stats)&#123;</span><br><span class="line">          if(eror)&#123;</span><br><span class="line">            console.warn(&apos;获取文件stats失败&apos;);</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            var isFile = stats.isFile();//是文件</span><br><span class="line">            var isDir = stats.isDirectory();//是文件夹</span><br><span class="line">            if(isFile)&#123;</span><br><span class="line">              if (reg.test(filedir)) &#123;</span><br><span class="line">                findurl(filedir);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isDir)&#123;</span><br><span class="line">              fileDisplay(filedir);//递归，如果是文件夹，就继续遍历该文件夹下面的文件</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　通过nodejs+babel查找所有js文件中的URL&lt;br&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础;</title>
    <link href="http://yoursite.com/2018/09/06/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/Linux基础/</id>
    <published>2018-09-06T08:56:02.000Z</published>
    <updated>2018-09-06T08:56:02.363Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Filter基础;</title>
    <link href="http://yoursite.com/2018/09/06/Filter%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/Filter基础/</id>
    <published>2018-09-06T08:55:30.000Z</published>
    <updated>2018-09-06T08:55:30.845Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis基础;</title>
    <link href="http://yoursite.com/2018/09/06/Redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/Redis基础/</id>
    <published>2018-09-06T08:54:55.000Z</published>
    <updated>2018-09-06T08:54:55.915Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker基础;</title>
    <link href="http://yoursite.com/2018/09/06/Docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/Docker基础/</id>
    <published>2018-09-06T08:54:28.000Z</published>
    <updated>2018-09-06T08:54:28.834Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MQ基础;</title>
    <link href="http://yoursite.com/2018/09/06/MQ%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/MQ基础/</id>
    <published>2018-09-06T08:54:20.000Z</published>
    <updated>2018-09-06T08:54:20.120Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hibernate进阶;</title>
    <link href="http://yoursite.com/2018/09/06/Hibernate%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/09/06/Hibernate进阶/</id>
    <published>2018-09-06T08:54:04.000Z</published>
    <updated>2018-09-06T08:54:04.037Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hibernate基础;</title>
    <link href="http://yoursite.com/2018/09/06/Hibernate%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/Hibernate基础/</id>
    <published>2018-09-06T08:53:46.000Z</published>
    <updated>2018-09-06T08:53:46.881Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatis进阶;</title>
    <link href="http://yoursite.com/2018/09/06/MyBatis%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/09/06/MyBatis进阶/</id>
    <published>2018-09-06T08:53:12.000Z</published>
    <updated>2018-09-06T08:53:12.901Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatis基础;</title>
    <link href="http://yoursite.com/2018/09/06/MyBatis%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/MyBatis基础/</id>
    <published>2018-09-06T08:52:55.000Z</published>
    <updated>2018-09-06T08:52:55.449Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot的数据访问;</title>
    <link href="http://yoursite.com/2018/09/06/SpringBoot%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2018/09/06/SpringBoot的数据访问/</id>
    <published>2018-09-06T08:51:17.000Z</published>
    <updated>2018-09-06T08:51:17.341Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot的Web开发;</title>
    <link href="http://yoursite.com/2018/09/06/SpringBoot%E7%9A%84Web%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/09/06/SpringBoot的Web开发/</id>
    <published>2018-09-06T08:51:07.000Z</published>
    <updated>2018-09-06T08:51:07.090Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot核心;</title>
    <link href="http://yoursite.com/2018/09/06/SpringBoot%E6%A0%B8%E5%BF%83/"/>
    <id>http://yoursite.com/2018/09/06/SpringBoot核心/</id>
    <published>2018-09-06T08:50:33.000Z</published>
    <updated>2018-09-06T08:50:33.903Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot基础</title>
    <link href="http://yoursite.com/2018/09/06/SpringBoot%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/SpringBoot基础/</id>
    <published>2018-09-06T08:50:21.000Z</published>
    <updated>2018-09-13T01:43:47.512Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC基础;</title>
    <link href="http://yoursite.com/2018/09/06/SpringMVC%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/SpringMVC基础/</id>
    <published>2018-09-06T08:50:03.000Z</published>
    <updated>2018-09-06T08:50:03.476Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring高级话题(二);</title>
    <link href="http://yoursite.com/2018/09/06/Spring%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/06/Spring高级话题/</id>
    <published>2018-09-06T08:49:21.000Z</published>
    <updated>2018-09-06T13:04:40.526Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p><h1 id="spring事务管理"><a href="#spring事务管理" class="headerlink" title="spring事务管理"></a>spring事务管理</h1><p>　　spring事务有四个优点：</p><ul><li>提供一致的对于不同的事务管理的API</li><li>支持声明式事务管理(重点)</li><li>编程事务管理(在开发中应用比较少)</li><li>优秀的整合与Spring的数据访问<h2 id="事务管理的API"><a href="#事务管理的API" class="headerlink" title="事务管理的API"></a>事务管理的API</h2><h3 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h3><h2 id="声明式事物"><a href="#声明式事物" class="headerlink" title="声明式事物"></a>声明式事物</h2><h3 id="开启声明式事务"><a href="#开启声明式事务" class="headerlink" title="开启声明式事务"></a>开启声明式事务</h3>spring开启声明式事务：<br>在application中<br>springBoot开启声明式事务：<br>，首先使用注解 <code>@EnableTransactionManagement</code>开启事务支持后，然后在访问数据库的Service方法上添加注解<code>@Transactional</code>便可。<h1 id="SpringAOP编程"><a href="#SpringAOP编程" class="headerlink" title="SpringAOP编程"></a>SpringAOP编程</h1><h1 id="Spring-jdbc-Template"><a href="#Spring-jdbc-Template" class="headerlink" title="Spring jdbc Template"></a>Spring jdbc Template</h1></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring常用配置(二);</title>
    <link href="http://yoursite.com/2018/09/06/Spring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/09/06/Spring常用配置/</id>
    <published>2018-09-06T08:49:12.000Z</published>
    <updated>2018-09-06T08:49:12.805Z</updated>
    
    <content type="html"><![CDATA[<p>　　这家伙很懒竟然没写摘要<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这家伙很懒竟然没写摘要&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring基础</title>
    <link href="http://yoursite.com/2018/09/06/Spring%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/06/Spring基础/</id>
    <published>2018-09-06T08:48:45.000Z</published>
    <updated>2018-09-13T01:43:35.852Z</updated>
    
    <content type="html"><![CDATA[<p>　　Spring框架是一个 轻量级的企业级开发的站式解决方案。 所谓解决方案就是可以基于Spring解决Java EE开发的所有问题。Spring框架主要提供了IoC 容器、AOP、数据访问、Web开发、消息、测试等相关技术的支持。<br>　　Spring使用简单的POJO (Plain Old Java Object,即无任何限制的普通Java对象)来进行企业级开发。每个被Spring管理的Java对象都称之为Bean;而Spring提供了一个IoC容器用来初始化对象，解决对象间的依赖管理和对象的使用。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>　　Spring框架是一个 轻量级的企业级开发的站式解决方案。 所谓解决方案就是可以基于Spring解决Java EE开发的所有问题。Spring框架主要提供了IoC 容器、AOP、数据访问、Web开发、消息、测试等相关技术的支持。<br>　　Spring使用简单的POJO (Plain Old Java Object,即无任何限制的普通Java对象)来进行企业级开发。每个被Spring管理的Java对象都称之为Bean;而Spring提供了一个IoC容器用来初始化对象，解决对象间的依赖管理和对象的使用。<br>　　Spring框架本身有四大基本原则：</p><ul><li><code>使用POJO进行轻量级和最小侵入式开发</code></li><li><code>通过依赖注入和基于接口编程实现松耦合</code></li><li><code>通过AOP和默认习惯进行声明式编程</code></li><li><code>使用AOP和模版减小模版式代码</code></li></ul><h2 id="Spring的模块"><a href="#Spring的模块" class="headerlink" title="Spring的模块"></a>Spring的模块</h2><p>　　spring是模块化的，这就意味着你可以只使用你需要的spring模块。spring的模块如下所示：<br><img src="/img/Spring模块.png" alt="Spring模块"></p><h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><ul><li>Sning-Core：核心工具类，Sping其他模块大最使用SingCcre;</li><li>Spring-Beans：Spring 定义Bean的支持;</li><li>Spring-Context：运行时Spring容器;</li><li>Spring-Context-Support：Spring容器对第三方包的集成支持;</li><li>Spring Expression：使用表达式语言在运行时查询和操作对象;</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul><li>Spring-AOP：基于代理的AOP支持;</li><li>Spring-Aspects：基于AspeetU的AOP支持。</li></ul><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><ul><li>Spring Messaging：对消息架构和协议的支持。</li></ul><h3 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h3><ul><li>Spring-Web：提供基础的Web集成的功能，在Web项目中提供Spring的容器;</li><li>Spring Webmve：提供基于Servlet的Spring MVC;</li><li>Spring WebSocket：提供WebSocket功能;</li><li>Spring Webmve Porlet：提供Portlet环境支持。</li></ul><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul><li>SpingJDBC：提供以IDBC访问数据库的支持;</li><li>Sping-TX：提供编程式和声明式的事务支持;</li><li>Spring-ORM:提供对对象关系映射技术的支持;</li><li>SpingOXM:提供对对象人xml映射技术的支持;Snig-M提供对IMS的支持。</li></ul><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>　　spring进行配置的方式本有三种：配置文件方式，注解方式和java类方式，但是由于现在较为常用的是使用springBoot进行开发提倡零配置约定大于配置默认不在有web.xml等配置文件，所以不再考虑配置文件方式。</p><h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><h3 id="配置包扫描"><a href="#配置包扫描" class="headerlink" title="配置包扫描"></a>配置包扫描</h3><h3 id="Bean的实例化方法"><a href="#Bean的实例化方法" class="headerlink" title="Bean的实例化方法"></a>Bean的实例化方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><h4 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h4><h3 id="Bean的属性注入"><a href="#Bean的属性注入" class="headerlink" title="Bean的属性注入"></a>Bean的属性注入</h3><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><h4 id="Setter方法注入"><a href="#Setter方法注入" class="headerlink" title="Setter方法注入"></a>Setter方法注入</h4><h4 id="集合属性注入"><a href="#集合属性注入" class="headerlink" title="集合属性注入"></a>集合属性注入</h4><h2 id="java类方式"><a href="#java类方式" class="headerlink" title="java类方式"></a>java类方式</h2><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>　　我们经常说的控制翻转(Inversion of Control-I0C)和依赖注入(dependency injecton-D)在Spring环境下是等同的概念，控制翻转是通过依赖注入实现的。所谓依赖注入指的是容基负责创建对象和维护对象的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。<br>　　依赖注入的主要目的是为了解耦，体现了种“组合”的理念。如果你希望你的类具各某项功能的时候，是继承自一个具有此功能的父类好呢?还是组合另外一个具有这个功能的类好呢?答案是不言而喻的，继承一个父类，子类将与父类耦合，组合另外一个类则使耦合度大大降低。<br>　　Spring IoC容器(ApplicationContext)负责创建Bcan，并通过容器将功能类Bean注入到你需要的Bean中。Spring 提供使用xml、注解、Java 配置、groovy 配置实现Bean的创建和注入。<br>　　<code>声明Bean的注解:</code></p><ul><li>@Component组件，没有明确的角色,</li><li>@Service在业务逻辑层( service层)使用,</li><li>@Repository在数据访问层(dao层)使用,</li><li>@Conroller在展现层(MVC- Spring MVC)使用,</li></ul><p>　　<code>注入Bean的注解,一般情况下通用</code></p><ul><li>@Autowired: Spring 提供的注解,</li><li>@Inject: JSR-330提供的注解,</li><li>@Resource: JSR 250提供的注解,</li></ul><p>　　@Autowired. @Inject. @Resurce可注解在se方法上或者属性上，建议注解在属性上，优点是代码更少、层次更清晰。</p><h1 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h1><p>　　AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>　　AOP是一个概念，并没有设定具体语言的实现，它能克服那些只有单继承特性语言的缺点，spring2.0之后整合AspectJ第三方AOP技术。AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>　　日志记录，性能统计，安全控制，事务处理，异常处理等等</p><h2 id="主要意图"><a href="#主要意图" class="headerlink" title="主要意图"></a>主要意图</h2><p>　　将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p><h2 id="AOP底层实现"><a href="#AOP底层实现" class="headerlink" title="AOP底层实现"></a>AOP底层实现</h2><p>　　AOP分为静态AOP和动态AOP。静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。动态AOP是指将切面代码进行动态织入实现的AOP。Spring的AOP为动态AOP，实现的技术为： JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术)。</p><h3 id="JDK动态代理和CGLIB动态代理"><a href="#JDK动态代理和CGLIB动态代理" class="headerlink" title="JDK动态代理和CGLIB动态代理"></a>JDK动态代理和CGLIB动态代理</h3><ul><li>jdk的动态代理只可以为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理。</li><li>如果目标对象，有接口，优先使用jdk动态代理；如果目标对象，无接口，使用cglib动态代理。</li></ul><h2 id="AOP开发"><a href="#AOP开发" class="headerlink" title="AOP开发"></a>AOP开发</h2><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h3 id="IOC和DI区别"><a href="#IOC和DI区别" class="headerlink" title="IOC和DI区别?"></a>IOC和DI区别?</h3><p>　　IOC 控制反转，是指对象实例化权利由spring容器来管理<br>　　DI 依赖注入 在spring创建对象的过程中，对象所依赖的属性通过配置注入对象中，在Spring环境下是等同的概念。</p><h3 id="ApplicationContext与BeanFactory关系"><a href="#ApplicationContext与BeanFactory关系" class="headerlink" title="ApplicationContext与BeanFactory关系"></a>ApplicationContext与BeanFactory关系</h3><p><img src="/img/ApplicationContext与BeanFactory关系.png" alt=""><br>　　ApplicationContext它是扩展BeanFactory接口。BeanFactory它采取延迟加载的方案，只有真正在getBean时才会实例化Bean,在开发中我们一般使用的是ApplicationContext,真正使用的是其实现类AppliCationContext它会在配置文件加载时，就会初始化Bean,并且ApplicationContext它提供不同的应用层的Context实现。例如在web开发中可以使用WebApplicationContext<br>　　<code>FileSystemXmlAppliCationContext 根据文件路径获取</code><br>　　<code>ClassPathXmlApplicationContext  根据类路径获取</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Spring框架是一个 轻量级的企业级开发的站式解决方案。 所谓解决方案就是可以基于Spring解决Java EE开发的所有问题。Spring框架主要提供了IoC 容器、AOP、数据访问、Web开发、消息、测试等相关技术的支持。&lt;br&gt;　　Spring使用简单的POJO (Plain Old Java Object,即无任何限制的普通Java对象)来进行企业级开发。每个被Spring管理的Java对象都称之为Bean;而Spring提供了一个IoC容器用来初始化对象，解决对象间的依赖管理和对象的使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
</feed>
